using BenchmarkDotNet.Attributes;
using CsvHelper;
using Sylvan.Data.Csv;
using System.Globalization;
using System.Text;
using nietras.SeparatedValues;

namespace FastCsv.Benchmarks;

/// <summary>
/// File I/O performance comparison for CSV libraries
/// Tests reading from actual files vs in-memory strings
/// </summary>
[MemoryDiagnoser]
[SimpleJob(warmupCount: 2, iterationCount: 3)]
public class FilePerformanceBenchmark
{
    private string _tempFilePath = "";
    private string _csvContent = "";

    [GlobalSetup]
    public void Setup()
    {
        // Create a test CSV file
        var sb = new StringBuilder();
        sb.AppendLine("OrderID,CustomerID,Product,Quantity,Price,OrderDate,ShipAddress");
        
        var random = new Random(42); // Fixed seed for consistency
        for (int i = 1; i <= 5000; i++)
        {
            sb.AppendLine($"{i},CUST{i % 100:D3},Product{i % 50},{random.Next(1, 10)},{random.Next(10, 1000)}.99,2024-{random.Next(1, 13):D2}-{random.Next(1, 29):D2},\"{random.Next(1, 9999)} Main St, City {i % 20}\"");
        }
        
        _csvContent = sb.ToString();
        
        // Write to temp file
        _tempFilePath = Path.GetTempFileName();
        File.WriteAllText(_tempFilePath, _csvContent);
    }

    [GlobalCleanup]
    public void Cleanup()
    {
        if (File.Exists(_tempFilePath))
            File.Delete(_tempFilePath);
    }

    // ============= FastCsv File Reading =============

    [Benchmark(Baseline = true)]
    [BenchmarkCategory("FastCsv")]
    public int FastCsv_ReadFile_String()
    {
        var content = File.ReadAllText(_tempFilePath);
        var records = global::FastCsv.Csv.ReadAllRecords(content);
        return records.Count;
    }

    [Benchmark]
    [BenchmarkCategory("FastCsv")]
    public int FastCsv_ReadFile_Memory()
    {
        var content = File.ReadAllText(_tempFilePath);
        var memory = content.AsMemory();
        var records = global::FastCsv.Csv.ReadAllRecords(memory);
        return records.Count;
    }

    [Benchmark]
    [BenchmarkCategory("FastCsv")]
    public int FastCsv_Stream()
    {
        using var stream = File.OpenRead(_tempFilePath);
        using var reader = global::FastCsv.Csv.CreateReader(stream);
        var count = 0;
        while (reader.TryReadRecord(out _))
        {
            count++;
        }
        return count;
    }

    // ============= In-Memory Comparison =============

    [Benchmark]
    [BenchmarkCategory("FastCsv")]
    public int FastCsv_InMemory_String()
    {
        var records = global::FastCsv.Csv.ReadAllRecords(_csvContent);
        return records.Count;
    }

    [Benchmark]
    [BenchmarkCategory("FastCsv")]
    public int FastCsv_InMemory_Memory()
    {
        var memory = _csvContent.AsMemory();
        var records = global::FastCsv.Csv.ReadAllRecords(memory);
        return records.Count;
    }

    // ============= Competitor File Reading =============

    [Benchmark]
    [BenchmarkCategory("CsvHelper")]
    public int CsvHelper_FileStream()
    {
        using var reader = new StreamReader(_tempFilePath);
        using var csv = new CsvReader(reader, CultureInfo.InvariantCulture);
        
        var count = 0;
        while (csv.Read())
        {
            count++;
        }
        return count;
    }

    [Benchmark]
    [BenchmarkCategory("CsvHelper")]
    public int CsvHelper_FileContent()
    {
        var content = File.ReadAllText(_tempFilePath);
        using var reader = new StringReader(content);
        using var csv = new CsvReader(reader, CultureInfo.InvariantCulture);
        
        var count = 0;
        while (csv.Read())
        {
            count++;
        }
        return count;
    }

    [Benchmark]
    [BenchmarkCategory("Sylvan")]
    public int Sylvan_FileStream()
    {
        using var reader = new StreamReader(_tempFilePath);
        using var csv = CsvDataReader.Create(reader);
        
        var count = 0;
        while (csv.Read())
        {
            count++;
        }
        return count;
    }

    [Benchmark]
    [BenchmarkCategory("Sylvan")]
    public int Sylvan_FileContent()
    {
        var content = File.ReadAllText(_tempFilePath);
        using var reader = new StringReader(content);
        using var csv = CsvDataReader.Create(reader);
        
        var count = 0;
        while (csv.Read())
        {
            count++;
        }
        return count;
    }

    [Benchmark]
    [BenchmarkCategory("Sep")]
    public int Sep_FileContent()
    {
        var content = File.ReadAllText(_tempFilePath);
        using var reader = Sep.Reader().FromText(content);
        
        var count = 0;
        foreach (var row in reader)
        {
            count++;
        }
        return count;
    }

    [Benchmark]
    [BenchmarkCategory("Sep")]
    public int Sep_FileReader()
    {
        using var fileReader = new StreamReader(_tempFilePath);
        using var reader = Sep.Reader().From(fileReader);
        
        var count = 0;
        foreach (var row in reader)
        {
            count++;
        }
        return count;
    }

    [Benchmark]
    [BenchmarkCategory("LumenWorks")]
    public int CsvReader_FileStream()
    {
        using var reader = new StreamReader(_tempFilePath);
        using var csv = new LumenWorks.Framework.IO.Csv.CsvReader(reader, true);
        
        var count = 0;
        while (csv.ReadNextRecord())
        {
            count++;
        }
        return count;
    }

    // ============= Raw File Operations =============

    [Benchmark]
    [BenchmarkCategory("Baseline")]
    public int Raw_ReadAllLines()
    {
        var lines = File.ReadAllLines(_tempFilePath);
        return lines.Length - 1; // Subtract header
    }

    [Benchmark]
    [BenchmarkCategory("Baseline")]
    public int Raw_ReadAllText_Split()
    {
        var content = File.ReadAllText(_tempFilePath);
        var lines = content.Split('\n', StringSplitOptions.RemoveEmptyEntries);
        return lines.Length - 1; // Subtract header
    }

    [Benchmark]
    [BenchmarkCategory("Baseline")]
    public int Raw_ReadLines_Enumerate()
    {
        var count = 0;
        foreach (var line in File.ReadLines(_tempFilePath))
        {
            count++;
        }
        return count - 1; // Subtract header
    }
}